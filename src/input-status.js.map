{"version":3,"file":"input-status.js","sourceRoot":"","sources":["input-status.ts"],"names":[],"mappings":"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","sourcesContent":["import {AbstractControl} from \"@angular/forms\";\n\n/**\n * Input status interface.\n *\n * This is a base class for input status implementations. Actual input status can be represented by one or more input\n * status objects of different types. Input status objects of different types could be distinguished by their\n * identifiers.\n *\n * There are several predefined input status implementations. Their payload is available via methods of the base\n * class.\n *\n * Input status object is meant to be immutable.\n */\nexport abstract class InputStatus {\n\n    /**\n     * Constructs input status.\n     *\n     * At most one object with the same identifier can exists within input status.\n     *\n     * @param _id a unique identifier of status object type.\n     */\n    constructor(private _id: string) {\n    }\n\n    /**\n     * An identifier of status object type.\n     *\n     * @return {string} the identifier passed to constructor.\n     */\n    get id(): string {\n        return this._id;\n    }\n\n    /**\n     * Nested input status object.\n     *\n     * @return {Array<InputStatus>} a list of nested input status objects.\n     */\n    get nested(): InputStatus[] {\n        return [];\n    }\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * If some of the inputs are not ready, the submit would be prevented.\n     *\n     * When input is ready this does not necessarily mean that it is valid. Nevertheless, the validation errors won't be\n     * displayed for ready for submit inputs. This typically means that user didn't entered the invalid data. On attempt\n     * to submit an invalid* input will be marked as non-ready, submit will be prevented, and errors will be displayed.\n     *\n     * This value can be set with `InputReady` and `InputNotReady` constants.\n     *\n     * @return {boolean}\n     */\n    get ready(): boolean {\n\n        const readiness = this.get(inputReadinessId);\n\n        return readiness == null || readiness.ready;\n    }\n\n    /**\n     * Input errors.\n     *\n     * Input errors could be set with `inputErrors()` method.\n     *\n     * @return {{}|undefined} a map of input errors, if any.\n     */\n    get errors(): {[key: string]: any} | undefined {\n\n        const errors = this.get(inputErrorsId);\n\n        return errors && errors.errors;\n    }\n\n    /**\n     * A control, which status is represented by this status.\n     *\n     * The control can be set with `inputStatusControl()` method.\n     *\n     * Note that when the status is merged from multiple controls, this value will be undefined.\n     *\n     * @return {AbstractControl|undefined} a control instance, if eny.\n     */\n    get control(): AbstractControl | undefined {\n\n        const statusControl = this.get(inputStatusControlId);\n\n        return statusControl && statusControl.control;\n    }\n\n    /**\n     * An input status object with the given identifier.\n     *\n     * @param id target identifier.\n     *\n     * @return {InputStatus} input status which identifier is equal to the given one, if any.\n     */\n    get(id: string): InputStatus | undefined {\n        return id === this.id ? this : undefined;\n    }\n\n    /**\n     * Checks whether this input status is equal to another one.\n     *\n     * @param status an input status object to compare this one with. If omitted the method will return `false`.\n     */\n    equals(status: InputStatus | null | undefined): boolean {\n        if (!status) {\n            return false;\n        }\n        if (status === this) {\n            return true;\n        }\n        if (this.id === status.id) {\n            if (this.nested.length != status.nested.length) {\n                return false;\n            }\n            if (!this.nested.length) {\n                return this.equalValues(status as this);\n            }\n        }\n        return this.combine().equalValues(status.combine());\n    }\n\n    /**\n     * Checks whether this status value (i.e. payload) equals to another one.\n     *\n     * This method is called for objects of the same type (i.e. with the same identifiers) by `equals()` method. Note\n     * that this method don't have to check for nested statuses equality. The `equals()` method would take care of this.\n     *\n     * @param status another status object to compare values with.\n     */\n    abstract equalValues(status: this): boolean;\n\n    /**\n     * Checks whether this input status is implied by another one.\n     *\n     * This method is called to remove unnecessary input statuses from combined ones.\n     *\n     * @param status another input status to check this one against.\n     */\n    impliedBy(status: InputStatus): boolean {\n        return status === this;\n    }\n\n    /**\n     * Merges two input statuses.\n     *\n     * @param status an input status to merge this one with.\n     *\n     * @return {InputStatus} new input status combined from the two ones.\n     */\n    merge(status: InputStatus): InputStatus {\n        if (status.impliedBy(this)) {\n            return this;\n        }\n        if (this.impliedBy(status)) {\n            return status;\n        }\n        if (this.id === status.id && !this.nested.length && !status.nested.length) {\n            return this.mergeValues(status as this);\n        }\n        return this.combine().add(status).optimize();\n    }\n\n    /**\n     * Merges two input status values (i.e. payloads).\n     *\n     * This method is called for objects of the same type (i.e. with the same identifiers) by `merge()` method. Note\n     * that this method don't have to merge nested statuses. The `merge()` method would take care of this.\n     *\n     * @param status merged input status.\n     */\n    abstract mergeValues(status: this): this;\n\n    private combine(): CombinedInputStatus {\n        return new CombinedInputStatus().add(this);\n    }\n\n}\n\nconst combinedInputStatusId = \"__combined__\";\n\nclass CombinedInputStatus extends InputStatus {\n\n    private readonly _map: {[key: string]: InputStatus} = {};\n    private _list?: InputStatus[];\n\n    constructor() {\n        super(combinedInputStatusId);\n    }\n\n    get(id: string | symbol): InputStatus | undefined {\n        return id === this.id ? this : this._map[id];\n    }\n\n    get nested(): InputStatus[] {\n        if (this._list) {\n            return this._list;\n        }\n\n        const list: InputStatus[] = [];\n\n        for (let id in this._map) {\n            if (this._map.hasOwnProperty(id)) {\n                list.push(this._map[id]);\n            }\n        }\n\n        this._list = list;\n\n        return list;\n    }\n\n    add(status: InputStatus): this {\n        if (status.impliedBy(this)) {\n            return this;\n        }\n        this._list = undefined;\n        if (status.id !== this.id) {\n\n            const prev: any = this._map[status.id];\n\n            if (!prev) {\n                this._map[status.id] = status;\n            } else {\n\n                const merged = prev.mergeValues(status);\n\n                if (!merged.impliedBy(this)) {\n                    this._map[status.id] = merged;\n                }\n            }\n        }\n        for (let st of status.nested) {\n            this.add(st);\n        }\n        return this;\n    }\n\n    equalValues(status: this): boolean {\n        return nestedMapContainsAll(this._map, status._map) && mapContainsKeys(status._map, this._map);\n    }\n\n    merge(status: InputStatus): this {\n        return super.merge(status) as this;\n    }\n\n    mergeValues(status: this): this {\n        return new CombinedInputStatus().add(this).add(status) as this;\n    }\n\n    optimize(): InputStatus {\n\n        const nested = this.nested;\n\n        if (nested.length <= 1) {\n            if (!nested.length) {\n                return InputReady;\n            }\n            return nested[0];\n        }\n\n        return this;\n    }\n\n}\n\nfunction nestedMapContainsAll(map: {[key: string]: InputStatus}, other: {[key: string]: InputStatus}): boolean {\n    for (let key in map) {\n        if (map.hasOwnProperty(key)) {\n            if (!map[key].equals(other[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nconst inputReadinessId = \"__readiness__\";\n\nclass InputReadiness extends InputStatus {\n\n    constructor(private _ready: boolean) {\n        super(inputReadinessId);\n    }\n\n    get ready(): boolean {\n        return this._ready;\n    }\n\n    impliedBy(status: InputStatus): boolean {\n        return this.ready === status.ready;\n    }\n\n    equalValues(status: this): boolean {\n        return this._ready === status._ready;\n    }\n\n    mergeValues(status: this): this {\n        return this.ready ? status : this;\n    }\n\n}\n\n/**\n * Ready for submit input status.\n */\nexport const InputReady: InputStatus = new InputReadiness(true);\n\n/**\n * Not ready for submit input status.\n */\nexport const InputNotReady: InputStatus = new InputReadiness(false);\n\n\n/**\n * Constructs input status control.\n *\n * The control instance will be available via `InputStatus.control` field.\n *\n * When merged with another input status the control value would be preserved, unless another input status represents\n * another control. In the latter case the control status would be dropped from merged status.\n *\n * @param control a control which status should be represented.\n */\nexport function inputStatusControl(control: AbstractControl): InputStatus {\n    return new InputStatusControl(control);\n}\n\nconst inputStatusControlId = \"__control__\";\n\nclass InputStatusControl extends InputStatus {\n\n    constructor(private _control?: AbstractControl) {\n        super(inputStatusControlId);\n    }\n\n    get control(): AbstractControl | undefined {\n        return this._control;\n    }\n\n    impliedBy(status: InputStatus): boolean {\n        return !this.control || this.control === status.control;\n    }\n\n    equalValues(status: this): boolean {\n        return this._control === status._control;\n    }\n\n    mergeValues(status: this): this {\n        if (!status._control || this._control === status._control) {\n            return this;\n        }\n        if (!this._control) {\n            return status;\n        }\n        return noInputStatusControl as this;\n    }\n\n}\n\nconst noInputStatusControl = new InputStatusControl(undefined);\n\n\n/**\n * Constructs input errors.\n *\n * The `errors` map will be available via `InputStatus.errors` field.\n *\n * @param errors a error map.\n */\nexport function inputErrors(errors: {[key: string]: any}): InputStatus {\n    return new InputErrors(errors);\n}\n\nconst inputErrorsId = \"__errors__\";\n\nclass InputErrors extends InputStatus {\n\n    constructor(private _errors: {[key: string]: any}) {\n        super(inputErrorsId);\n    }\n\n    get errors(): {[key: string]: any} {\n        return this._errors;\n    }\n\n    equalValues(status: this): boolean {\n        return equalMaps(this._errors, status._errors);\n    }\n\n    mergeValues(status: this): this {\n        if (this._errors === status._errors) {\n            return this;\n        }\n\n        const errors: {[key: string]: any} = {};\n\n        for (let key in this._errors) {\n            if (this._errors.hasOwnProperty(key)) {\n                errors[key] = this._errors[key];\n            }\n        }\n        for (let key in status._errors) {\n            if (status._errors.hasOwnProperty(key)) {\n                errors[key] = status._errors[key];\n            }\n        }\n\n        return new InputErrors(errors) as this;\n    }\n\n}\n\nfunction equalMaps(map1: {[key: string]: any}, map2: {[key: string]: any}) {\n    return mapContainsAll(map1, map2) && mapContainsKeys(map2, map1);\n}\n\nfunction mapContainsKeys(map: {[key: string]: any}, other: {[key: string]: any}): boolean {\n    for (let key in map) {\n        if (map.hasOwnProperty(key)) {\n            if (!other.hasOwnProperty(key)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction mapContainsAll(map: {[key: string]: any}, other: {[key: string]: any}): boolean {\n    for (let key in map) {\n        if (map.hasOwnProperty(key)) {\n            if (map[key] !== other[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n"]}